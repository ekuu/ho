// Code generated by "gogen option -n Cache -i m,mu -p _ --with-init"; DO NOT EDIT.

package cache

import (
	"fmt"
	"time"
)

// New constructor
func New[K comparable, V any](_opts ...Option[K, V]) *Cache[K, V] {
	_c := new(Cache[K, V])

	_c.SetOptions(_opts...)

	_c.init()
	return _c
}

// Option[K comparable,V any] option interface
type Option[K comparable, V any] interface {
	apply(*Cache[K, V])
}

// Option[K comparable,V any] option function
type optionFunc[K comparable, V any] func(*Cache[K, V])

func (f optionFunc[K, V]) apply(_c *Cache[K, V]) {
	f(_c)
}

func (_c *Cache[K, V]) SetOptions(_opts ...Option[K, V]) *Cache[K, V] {
	for _, _opt := range _opts {
		_opt.apply(_c)
	}
	return _c
}

func SkipOption[K comparable, V any]() Option[K, V] {
	return optionFunc[K, V](func(_c *Cache[K, V]) {
		return
	})
}

func WithOptions[K comparable, V any](o *options[K, V]) Option[K, V] {
	return optionFunc[K, V](func(_c *Cache[K, V]) {
		_c.SetOptions(o.opts...)
	})
}

// options[K comparable,V any] options struct
type options[K comparable, V any] struct {
	opts []Option[K, V]
}

// NewOptions[K comparable,V any] new options struct
func NewOptions[K comparable, V any]() *options[K, V] {
	return new(options[K, V])
}

func (_o *options[K, V]) Options() []Option[K, V] {
	return _o.opts
}

func (_o *options[K, V]) Append(_opts ...Option[K, V]) *options[K, V] {
	_o.opts = append(_o.opts, _opts...)
	return _o
}

// Interval interval option of Cache
func (_o *options[K, V]) Interval(interval time.Duration) *options[K, V] {
	_o.opts = append(_o.opts, WithInterval[K, V](interval))
	return _o
}

// Ttl ttl option of Cache
func (_o *options[K, V]) Ttl(ttl time.Duration) *options[K, V] {
	_o.opts = append(_o.opts, WithTtl[K, V](ttl))
	return _o
}

// WithInterval interval option of Cache
func WithInterval[K comparable, V any](interval time.Duration) Option[K, V] {
	return optionFunc[K, V](func(_c *Cache[K, V]) {
		_c.interval = interval
	})
}

// WithTtl ttl option of Cache
func WithTtl[K comparable, V any](ttl time.Duration) Option[K, V] {
	return optionFunc[K, V](func(_c *Cache[K, V]) {
		_c.ttl = ttl
	})
}

func PrintOptions(packageName string) {
	opts := []string{
		"WithInterval()",
		"WithTtl()",
	}
	if packageName == "" {
		fmt.Printf("opts := []Option{ \n")
		for _, v := range opts {
			fmt.Printf("	%s,\n", v)
		}
	} else {
		fmt.Printf("opts := []%s.Option{ \n", packageName)
		for _, v := range opts {
			fmt.Printf("	%s.%s,\n", packageName, v)
		}
	}
	fmt.Println("}")
}
