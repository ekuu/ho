// Code generated by "gogen option -n pool -s ctx,workerCap,recoverFunc -p _ --with-init"; DO NOT EDIT.

package gopool

import (
	"context"
	"fmt"
)

// New constructor
func New(_opts ...Option) *pool {
	_p := new(pool)

	_p.SetOptions(_opts...)

	_p.init()
	return _p
}

// Option option interface
type Option interface {
	apply(*pool)
}

// Option option function
type optionFunc func(*pool)

func (f optionFunc) apply(_p *pool) {
	f(_p)
}

func (_p *pool) SetOptions(_opts ...Option) *pool {
	for _, _opt := range _opts {
		_opt.apply(_p)
	}
	return _p
}

func SkipOption() Option {
	return optionFunc(func(_p *pool) {
		return
	})
}

func WithOptions(o *options) Option {
	return optionFunc(func(_p *pool) {
		_p.SetOptions(o.opts...)
	})
}

// options options struct
type options struct {
	opts []Option
}

// NewOptions new options struct
func NewOptions() *options {
	return new(options)
}

func (_o *options) Options() []Option {
	return _o.opts
}

func (_o *options) Append(_opts ...Option) *options {
	_o.opts = append(_o.opts, _opts...)
	return _o
}

// WorkerCap workerCap option of pool
func (_o *options) WorkerCap(workerCap int32) *options {
	_o.opts = append(_o.opts, WithWorkerCap(workerCap))
	return _o
}

// RecoverFunc recoverFunc option of pool
func (_o *options) RecoverFunc(recoverFunc func(ctx context.Context, r any)) *options {
	_o.opts = append(_o.opts, WithRecoverFunc(recoverFunc))
	return _o
}

// Ctx ctx option of pool
func (_o *options) Ctx(ctx context.Context) *options {
	_o.opts = append(_o.opts, WithCtx(ctx))
	return _o
}

// WithWorkerCap workerCap option of pool
func WithWorkerCap(workerCap int32) Option {
	return optionFunc(func(_p *pool) {
		_p.workerCap = &workerCap
	})
}

// WithRecoverFunc recoverFunc option of pool
func WithRecoverFunc(recoverFunc func(ctx context.Context, r any)) Option {
	return optionFunc(func(_p *pool) {
		_p.recoverFunc = recoverFunc
	})
}

// WithCtx ctx option of pool
func WithCtx(ctx context.Context) Option {
	return optionFunc(func(_p *pool) {
		_p.ctx = ctx
	})
}

func PrintOptions(packageName string) {
	opts := []string{
		"WithWorkerCap()",
		"WithRecoverFunc()",
		"WithCtx()",
	}
	if packageName == "" {
		fmt.Printf("opts := []Option{ \n")
		for _, v := range opts {
			fmt.Printf("	%s,\n", v)
		}
	} else {
		fmt.Printf("opts := []%s.Option{ \n", packageName)
		for _, v := range opts {
			fmt.Printf("	%s.%s,\n", packageName, v)
		}
	}
	fmt.Println("}")
}
